/** * This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License. * http://creativecommons.org/licenses/by-sa/3.0/ * * Juga Paazmaya <olavic@gmail.com> */{		function ExportCompTransition(thisObj)	{		var scriptName = "Export Transitions to QML";		var scriptVersion = "0.5";		var scriptDate = "2nd May 2012";				var dialog;		var outputFolder; // string, such as Folder.path		var compAll = true; // all compositions or just the selected?		 		var idCounter = 0;				var seqAnimList = [];						// Not good enough check as OS X should have same with Unix...		var lineFeed = (Folder.fs == "Windows" ? "\r\n" : (Folder.fs == "Unix" ? "\n" : ($.os.indexOf ("10") !== -1  ? "\n" : "\r")));				var dirSeparator = (Folder.fs == "Windows" ? "\\" : "/");		var qtQuickVersion = "2.0";				function BuildAndShowUI(thisObj) {					dialog = new Window("dialog", scriptName, undefined, {resizeable: false});			dialog.orientation = "column";			dialog.alignment = ["fill", "top"];			dialog.alignChildren = ["fill", "top"];			dialog.margins = [10,10,10,10];			dialog.spacing = 10;						var introText = dialog.add("statictext", undefined, "Start by choosing the output folder...\nBeware! The existing files in the selected folder will be overwritten.\nOnce exporting has finished, remember to copy the Prosessor.js file to the given folder.", { multiline: true });						// ---- output folder selection									var folderGroup = dialog.add("group");			folderGroup.alignment = ["fill", "center"];			folderGroup.alignChildren = ["fill", "center"];						var folderBox = folderGroup.add("panel");			folderBox.alignChildren = ["fill", "center"];			folderBox.orientation = "row";						var folderText = folderBox.add("statictext", undefined, "Output folder"); 			folderText.alignment = ["left", "center"];						dialog.folderEdit = folderBox.add("edittext", undefined, outputFolder);			dialog.folderEdit.alignment = ["fill", "center"];			dialog.folderEdit.helpTip = "The current output folder if any. Needs to exist in the file system. In case it has files with the same name as those that are exported, they are overwritten.";						var folderButton = folderBox.add("button", undefined, "Choose folder");			folderButton.alignment = ["right", "center"];			folderButton.size = folderButton.maximumSize = folderButton.minimumSize = folderButton.preferredSize = [100, 25];			folderButton.onClick = chooseFolder;			folderButton.helpTip = "Click to choose the output folder.";						// ----						// ---- radio buttons						var radioBox = dialog.add("panel");			radioBox .alignment = "fill";			radioBox .orientation = "column";			radioBox.alignChildren = ["fill", "center"];						var radioText = radioBox.add("statictext", undefined, "You may export either all of the Compositions or just the currently selected active Composition" );						var radioAll = radioBox.add("radiobutton", undefined, "All compositions");			radioAll.helpTip = "Export all Compositions if this option is selected";			radioAll.value = compAll;			radioAll.onActivate = function () {				compAll = true;			};			var radioSel = radioBox.add("radiobutton", undefined, "Only selected composition");			radioSel.helpTip = "Export only the currently active Composition if this option is selected";			radioSel.value = !compAll;			radioSel.onActivate = function () {				compAll = false;			};					// ----						// ---- Qt Quick version selector						var versionBox = dialog.add("panel");			versionBox.alignment = "fill";			versionBox.orientation = "row";			versionBox.alignChildren = ["fill", "center"];						var versionQuick1 = versionBox.add("radiobutton", undefined, "Qt Quick 1.1 (Qt 4.x). Simple easing");			versionQuick1.helpTip = "Use Qt Quick 1.1 import command";			versionQuick1.onActivate = function () {				qtQuickVersion = "1.1";			};			versionQuick1.value = (qtQuickVersion == "1.1" ? true : false);						var versionQuick2 = versionBox.add("radiobutton", undefined, "Qt Quick 2.0 (Qt 5.x). Use bezier curve easing");			versionQuick2.helpTip = "Use Qt Quick 2.0 import command";			versionQuick2.onActivate = function () {				qtQuickVersion = "2.0";			};			versionQuick2.value = (qtQuickVersion == "2.0" ? true : false);					// ----						// ---- line ending selection and prosess button						var centerGroup = dialog.add("group");			centerGroup.alignment = "fill";			centerGroup.orientation = "row";			centerGroup.alignChildren = ["fill", "center"];						// ---- line ending selection						var lineEndBox = centerGroup.add("panel");			lineEndBox.alignment = ["fill", "fill"];			lineEndBox.alignChildren = ["fill", "center"];						var lineEndText = lineEndBox.add("statictext", undefined, "Line ending markers and file format");						var lineEndN = lineEndBox.add("radiobutton", undefined, "Unix and Mac OS X (\\n - LF)");			lineEndN.helpTip = "Linux, Unix and Mac OS X use this";			lineEndN.onActivate = function () {				lineFeed = "\n";			};			lineEndN.value = (lineFeed == "\n" ? true : false);						var lineEndR = lineEndBox.add("radiobutton", undefined, "Mac OS 9 and before (\\r - CR)");			lineEndR.helpTip = "Older Mac (9 and before) used this";			lineEndR.onActivate = function () {				lineFeed = "\r";			};			lineEndR.value = (lineFeed == "\r" ? true : false);						var lineEndRN = lineEndBox.add("radiobutton", undefined, "Windows (\\r\\n - CR+LF)");			lineEndRN.helpTip = "Windows uses this";			lineEndRN.onActivate = function () {				lineFeed = "\r\n";			};			lineEndRN.value = (lineFeed == "\r\n" ? true : false);						// ---- prosess button						var buttonBox = centerGroup.add("panel");			buttonBox.alignment = ["fill", "fill"];			buttonBox.alignChildren = ["left", "center"];			buttonBox.margins = [30,30,30,30];						dialog.okButton = buttonBox.add("button", undefined, "Start Processing", {name: "ok"});			dialog.okButton.alignment = ["center", "center"];			dialog.okButton.size = dialog.okButton.maximumSize = dialog.okButton.minimumSize = dialog.okButton.preferredSize = [200, 40];			dialog.okButton.onClick = startProcessing;			dialog.okButton.helpTip = "Click here to start prosessing the compositions and to save them as QML files.";						// ----						// ---- progress bar. Color missing...						var brush = dialog.graphics.newBrush(dialog.graphics.BrushType.SOLID_COLOR, [0.1, 0.7, 0.2]);			var pen = dialog.graphics.newPen(dialog.graphics.PenType.SOLID_COLOR, [0.1, 0.7, 0.2], 4);						dialog.barProgress = dialog.add("progressbar", undefined, 0, 100);			dialog.barProgress.alignment = ["fill", "center"];			dialog.barProgress.helpTip = "Current status of the prosess.";			dialog.barProgress.onDraw = function () {						};			//dialog.barProgress.maxvalue = 100; // default 100			//dialog.barProgress.graphics.foregroundColor = pen;			// ----						// ---- log window						dialog.logText = dialog.add("edittext", undefined, "Assuming your operating system is " + File.fs + " (" + $.os + ")" + ".\n", { multiline: true } );			dialog.logText.alignment = ["fill", "fill"];			dialog.logText.helpTip = "Log output of this script is shown here";			dialog.logText.size = [600, 200];			// ----			var bottomGroup = dialog.add("group");			bottomGroup.alignment = ["fill", "fill"];			bottomGroup.alignChildren = ["left", "center"];			// ---- about button						var aboutButton = bottomGroup.add("button", undefined, "About", {name: "help"});			aboutButton.alignment = ["left", "bottom"];			aboutButton.helpTip = "About this After Effects script";			aboutButton.size = aboutButton.maximumSize = aboutButton.minimumSize = aboutButton.preferredSize = [100, 25];			aboutButton.onClick = function () {				alert(scriptName + " by PAAZMAYA.com" + "\n" +					"This script was made to help design work flow in moving transitions from After Effects to QML." +					"\n\n" + "Current version " + scriptVersion + " was made in " + scriptDate + " and is provided as is. No warranty.",					scriptName + " by PAAZMAYA.com");			};						// ----			// ---- close button				dialog.closeButton = bottomGroup.add("button", undefined, "Close", {name: "cancel"});			dialog.closeButton.alignment = ["right", "bottom"];			dialog.closeButton.helpTip = "Closes this dialog";			dialog.closeButton.size = dialog.closeButton.maximumSize = dialog.closeButton.minimumSize = dialog.closeButton.preferredSize = [100, 25];			dialog.closeButton.onClick = function () {				dialog.close();			};					// -----			dialog.onResizing = dialog.onResize = function () {				this.layout.resize();			};			dialog.layout.layout();			dialog.center();			dialog.show();								}						// helpers		function round2(num) {			return Math.round(num * 100) / 100;		}			function uniqueId() {			return ++idCounter;		}			function interpolationTypeString(key) {			var msg = "not found";			switch (key) {				case KeyframeInterpolationType.LINEAR: msg = "linear"; break;				case KeyframeInterpolationType.BEZIER: msg = "bezier"; break;				case KeyframeInterpolationType.HOLD: msg = "hold"; break;			}			return msg;		}			// it seems Adobe implementation of replace only triggers once per character...		function replaceNoGoodName(name) {			var notWanted = [" ", "	", "-", "/", "\\", ".", "?", "=", "%"];			var len = notWanted.length;			for (var i = 0; i < len; i++) {				var c = notWanted[i];				while (name.indexOf(c) !== -1) {					name = name.replace(c, "_");				}			}			return name;		}			function objectValues(obj) {			var list = [];			if (typeof obj === "undefined" || !obj) {				return list;			}					for (var key in obj) {				if (obj.hasOwnProperty(key)) {					var k = obj[key];					if (k != null) {												//list.push(key + ": " + k.toString());																		if (typeof k == "object") {							list.push(key + ": [ " + objectValues(k) + " ] ");						}						else {							list.push(key + ": " + k.toString());						}											}				}			}			return list.join(", ");		}				// filename is without path.		function saveFile(filename, content) {			var path = outputFolder + dirSeparator + filename;			var f = new File(path);			var os = (lineFeed == "\r\n" ? "Windows" : (lineFeed == "\n" ? "Unix" : "Macintosh"));			f.lineFeed = os;			f.open("w");			f.write(content);			f.close();									dialog.logText.text += "Line feed for: " + filename + " is " + f.lineFeed + "\n";		}			function chooseFolder() {			var path = outputFolder ? outputFolder : app.project.file.path;			var dir = new Folder(path);						// Folder, File or null			var answer = dir.selectDlg("Please choose a directory where to export the QML files...");						if (answer != null) {				outputFolder = answer.absoluteURI;				dialog.folderEdit.text = outputFolder;				dialog.okButton.enabled = true;			}			dialog.logText.text += "Selected output directory: " + outputFolder + "\n";		}				function startProcessing() {			// which one is selected, all or just selected comp?			dialog.okButton.enabled = false;			dialog.closeButton.enabled = false;						var compositions = [];			var names = [];						var pBar = dialog.barProgress;						// get a list of compositions which are to be turned to QML files			if (compAll) {				compositions = listCompositions(app.project);			}			else {				compositions.push(app.project.activeItem);			}					dialog.logText.text += "Found " + compositions.length + " compositions\n";					pBar.value = 6;										// now parse and save the contents....			var len = compositions.length;			var increment = 89 / len; // 95 - 6 = 89						for (var i = 0; i < len; i++) {				// prosess....				var comp = compositions[i];				var stuff = "// Composition: " + comp.parentFolder.name + " >  " + comp.name + lineFeed + lineFeed + loopLayers(comp.layers);				var name = replaceNoGoodName(comp.parentFolder.name + "_" + comp.name);				names.push("\"" + name + "\"");												pBar.value += increment / 2;								// save file...				dialog.logText.text += "Saving file:  " + name + ".qml\n";				var qml = renderCommonQML(stuff);				saveFile(name + ".qml", qml);								pBar.value += increment / 2;			}			// progressBar is now 95%					dialog.logText.text += "Saved  " + names.length + " compositions to QML files\n";						// create main QML file			var mainName = replaceNoGoodName(app.project.file.displayName);						// Sort names			names.sort();						var qmlMain = [				"id: main",				"",				"property real speedRatio: 1.0",				"property int currentTime: 0 // ms",				"property int currentIndex: 0 // index of qmlFiles",				"property variant qmlFiles: [",				"\t" + names.join("," + lineFeed + "\t"),				"]",				"property alias loader: pageLoader", 				(qtQuickVersion != "2.0" ? "// " : "") + "property alias canvas: canvasList",				"property alias toolTip: toolTipBox",				"property variant runningAnimations: [] // currently running animations",				"",				"color: \"royalblue\"",				"",				"focus: true",										"Keys.onPressed: {",				 "if (event.key == Qt.Key_Left) {",				 "}",				"}", // Keys.onPressed								"Keys.onSpacePressed: {",				// pause animations....				"console.log(\"space pressed\");", 				"}", // Keys.onSpacePressed				"",								"Loader {",				"id: pageLoader",				"anchors.fill: parent",				"anchors.margins: 80",				"source: main.qmlFiles[main.currentIndex] + \".qml\"",								"onLoaded: {",				"pageTimer.restart();",				"main.currentTime = 0;",				"Prosessor.fillTimeLine();",				"}", // onLoaded								"}", // Loader								"Timer {",				"id: pageTimer",				"interval: 10 // milliseconds",				"repeat: true",				"running: false",				"onTriggered: {",				"currentTime += pageTimer.interval * main.speedRatio;",				"Prosessor.timerTriggered();",				"}", // onTriggered				"}", // Timer								"Rectangle {",				"id: pageMenu",				"height: 30",				"width: parent.width",				"x: 0",				"y: 0",				"color: \"black\"",								"Row {",				"anchors.fill: parent",								"Text {",				"font.pixelSize: 18",				"text: \"Prev\"",				"color: \"white\"",				"width: parent.width / 4",				"height: parent.height",				"horizontalAlignment: Text.AlignHCenter",				"verticalAlignment: Text.AlignVCenter",								"MouseArea {",				"anchors.fill: parent",				"onClicked: main.currentIndex > 0 ? main.currentIndex-- : main.currentIndex = main.qmlFiles.length - 1;",				"}", // MouseArea								"}", // Text								"Text {",				"id: labelCurrent",				"font.pixelSize: 20",				"text: \"[\" + main.currentIndex + \"] \" + main.qmlFiles[main.currentIndex]",				"color: \"pink\"",				"width: parent.width / 2",				"height: parent.height",				"horizontalAlignment: Text.AlignHCenter",				"verticalAlignment: Text.AlignVCenter",				"}", // Text								"Text {",				"font.pixelSize: 18",				"text: \"Next\"",				"color: \"white\"",				"width: parent.width / 4",				"height: parent.height",				"horizontalAlignment: Text.AlignHCenter",				"verticalAlignment: Text.AlignVCenter",								"MouseArea {",				"anchors.fill: parent",				"onClicked: main.currentIndex < main.qmlFiles.length - 1 ? main.currentIndex++ : main.currentIndex = 0;",				"}", // MouseArea								"}", // Text				"}", // Row								"}", // Rectangle								"Column {",				"id: timeLineColumn",				"spacing: 0",				"width: parent.width",				"x: 0",				"y: parent.height - 60",				"Repeater {",				"id: timeLine",								"",				"Rectangle {",				"color: modelData.color",				"width: modelData.duration",				"x: modelData.inTime",				"height: 60 / timeLine.count",				"}", // Rectangle				"}", // Repeater								"}", // Column								"Rectangle {",				"id: timeLineKey",				"width: 2",				"height: timeLineColumn.height + 4",				"color: \"white\"",				"border.color: \"black\"",				"border.width: 1",				"y: timeLineColumn.y - 2",				"x: 0",				"}", // Rectangle								"",								"Rectangle {",				"id: toolTipBox",				"property string text",				"visible: false",				"width: childrenRect.width + 4",				"height: childrenRect.height + 4",				"radius: height / 4",				"color: \"white\"",				"border.width: 1",				"border.color: \"black\"",				"opacity: 0.7",								"Text {",				"anchors.centerIn: parent",				"text: toolTipBox.text",				"}", // Text								"}", // Rectangle				""			];						if (qtQuickVersion == "2.0") {				qmlMain.push(					"Canvas {",					"id: canvasList",					"anchors.top: parent.top",					"anchors.topMargin: pageMenu.height",					"anchors.bottom: parent.bottom",					"anchors.right: parent.right",					"width: 60",					"}" // Canvas				);			}						dialog.logText.text += "Saving main file:  " + mainName + ".qml\n";			saveFile(mainName + ".qml", renderCommonQML(qmlMain.join(lineFeed)));						// Update the progress bar			pBar.value = 98;					// and finally create the QML project file...			var qmlProject = [				"import QmlProject 1.1",				"",				"Project {",				"    mainFile: \"" + mainName + ".qml\"", // in Qt 5, the mainFile will be locked if used				"    QmlFiles {",				"        directory: \".\"",				"    }",				"    JavaScriptFiles {",				"        directory: \".\"",				"    }",				"    ImageFiles {",				"        directory: \".\"",				"    }",				"}",				""			];			dialog.logText.text += "Saving project file:  " + mainName + ".qmlproject\n";			saveFile(mainName + ".qmlproject", qmlProject.join(lineFeed));						pBar.value = 100;			dialog.logText.text += "\nCompleted!\n";						// First line in alert is bold...			alert("Exporting Complete" + "\n" + "Export to QML files with Qt Quick " + qtQuickVersion + " has been completed", "Exporting Complete");						$.writeln("Exporting Complete");						// Re enable buttons			dialog.okButton.enabled = true;			dialog.closeButton.enabled = true;		}							function listCompositions(folder) {			var list = [];						var len = folder.numItems;			for (var i = 0; i < len; i++) {				var item = folder.item(i + 1); // The index numbering of a collection starts with 1, not 0.								// A user-readable name for the item type; for example, “Folder”, “Footage”, or “Composition”.				if (item.typeName == 'Folder') {					list.concat(listCompositions(item));				}				else  if (item.typeName == 'Composition') {					// compItem is the only that has layers... according to CS3 docs.					list.push(item);				}			}								return list;		}					// loop thru layers that have transform		function loopLayers(layers) {						var qmlRect = [];			// iterate from bottom to up			var llen = layers.length;			while (llen > 0) {				var layer = layers[llen];				llen--;								var layerTrans = layer.transform;				var id = "lay_" + replaceNoGoodName(layer.name).toLowerCase();				id += "_" + uniqueId();								// for this it is needed to loop thru properties and check for isEffect				var layerEffect = layer.property("Effects");								qmlRect.push(					"// Effects: value " + layerEffect.value //objectValues(layerEffect)				);								var layerPosition = layer.property("Position");				var layerScale = layer.property("Scale");				var layerOpacity = layer.property("Opacity");				var layerAnchor = layer.property("anchorPoint");								var anchorX = round2(layerAnchor.value[0]);				var anchorY = round2(layerAnchor.value[1]);												qmlRect.push(					"// Position: " + layerPosition.value.toString(),					"// Scale: " + layerScale.value.toString(),					"// Opacity: " + layerOpacity.value.toString(),					"// Anchor: " + layerAnchor.value.toString()				);								// by default the layer.name is the source path								qmlRect.push(					"Rectangle {",					"id: " + id,					"",					"property string layerName: \"" + layer.name + "\"",					"property int startTime: " + Math.round(layer.startTime * 1000) + " // ms",					"property int inTime: " + Math.round(layer.inPoint * 1000) + " // ms",					"property int outTime: " + Math.round(layer.outPoint * 1000) + " // ms",					"",					"transformOrigin: Item.Center",					"",					"x: " + round2(layerPosition.value[0] - anchorX) + " // " + layerPosition.value[0] + " - " +  anchorX,					"y: " + round2(layerPosition.value[1] - anchorY) + " // " + layerPosition.value[1] + " - " +  anchorY,					"visible: (inTime < main.currentTime ? true : false)", // && main.currentTime < outTime 					"scale: " + round2(layerScale.value[0] / 100),					"//opacity: " + round2(layerOpacity.value / 100),					"",					"opacity: main.currentTime > outTime ? 0.1 : 0.5 // for testing purposes only... after out time, 0.1",					""				);								var w = Math.round(layer.width / 2);				var h = Math.round(layer.height / 2);				var c = "Qt.rgba(Math.random(), Math.random(), Math.random(), 1)";				// Special case for finger....				if (id.indexOf("finger_") !== -1) {					w = h = 40;					c = "\"darkorange\"";					qmlRect.push(						"radius: width / 2"					);				}								qmlRect.push(					"width: " + w,					"height: " + h,					"color: " + c,				);								if (layerTrans.matchName.indexOf("Transform") !== -1) {					var trans = loopTransform(layerTrans, id, anchorX, anchorY);					var list = "property variant animList: [" + lineFeed + "\t\t" + seqAnimList.join("," + lineFeed + "\t\t") + lineFeed + "\t]";					qmlRect.push(						list,						trans					);					seqAnimList = []; // clear the temp list				}							// undefined....				//list.push("layerEffect.matchName: " + layerEffect.matchName);								// Looking for tints				/*				if (layerEffect.matchName.indexOf("Effects") !== -1) {													}				*/													qmlRect.push(					"Text {",					"anchors.fill: parent",					"anchors.margins: 6",					"text: parent.layerName",					"wrapMode: Text.WordWrap",					"font.pointSize: 14",					"}" // Text				);								qmlRect.push(					"MouseArea {",					"anchors.fill: parent",					"acceptedButtons: Qt.LeftButton | Qt.RightButton",					"hoverEnabled: true",										"onEntered: {",					"Prosessor.showTooltip(mouseX + " + id + ".x, mouseY + " + id + ".y, parent.layerName);",					"}", // onEntered										"onExited: {",					"Prosessor.hideTooltip();",					"}", // onExited										"onClicked: {",					"if (mouse.button == Qt.LeftButton) {",					"//Prosessor.runSequence(parent)",					"}", // if					"else if (mouse.button == Qt.RightButton) {",					"//" + id + ".visible = false",					"}", // else if					"}", // onClicked										"}", // MouseArea					""				);								qmlRect.push(					"",					"}" // Rectangle				);											}			return qmlRect.join(lineFeed + "\t");		}			// position needs to know anchoring as in QML is always from top left corner		function loopTransform(layerTrans, layerName, anchorX, anchorY) {			var qmlItem = [];						/*				For AVLayer:				• "Anchor Point" or "anchorPoint"				• "Position" or "position"				• "Scale" or "scale"				• "Rotation" or "rotation"				• "Z Rotation" or "zRotation" or "Rotation Z" or "rotationZ"				• "Opacity" or "opacity"				• "Marker" or "marker"			*/					// keys seem to be indexed starting from 1			var keysTest = [				"anchorPoint", // AnchorAnimation, AnchorChanges				"position", // NumberAnimation, PropertyChanges				"scale", // NumberAnimation				"rotation", // RotationAnimation				"opacity", // NumberAnimation				"rotationZ" // NumberAnimation			];			// RotationAnimation { duration: 1000; direction: RotationAnimation.Counterclockwise }			var kLen = keysTest.length;						for (var k = 0; k < kLen; k++) {								var key = keysTest[k];				if (layerTrans.hasOwnProperty(key) && layerTrans.property(key).numKeys > 0) {					var num = layerTrans.property(key).numKeys;															var initValue;					var prevTime; 					var prevValue; // from:					var id = replaceNoGoodName(layerName + "_" + key);										// QML Animations					var qmlAnim = [						//"AnimationController {",						//"id: ac_" + id, 						"",						//"// key: " + key,						"SequentialAnimation {",						"id: " + id,						"property variant sTarget: " + layerName,						"property bool alreadyRunOnce: false",						"//running: main.currentTime > " + id + ".initTime",						"onStarted: console.log(\"" + id + " just started, initTime: \" + initTime)",						//"onCompleted: console.log(\"" + id + " just completed.\")",						//"onCompleted: running = false // prevent looping",						""					];					// save the id list for launching					seqAnimList.push(id);										var qmlPropSet = []; // used only for position as it has x and y																	//dialog.logText.text += "Iterating transform for layer: " + layerName + ", k: " + k + "\n";										for (var index = 1; index <= num; index++) {																							var pgk = layerTrans.property(key);												var qmlAnimSet = [];						var comments = [];																				var time = pgk.keyTime(index);						var value = pgk.keyValue(index);												// In case this is the first item, use it as zero.						if (index == 1) {							initValue = value;							prevTime = time;														dialog.logText.text += "initValue for layer: " + layerName + " at key: " + key + " and index: " + index + " is " + initValue.toString() + "\n";														qmlAnim.push(								"property int initTime: " + Math.round(time * 1000) + " // ms",								"property variant initValue: [" + value.toString() + "]",								""							);														continue; // jump to next iteration.						}						var parsedValue;						var parsedTime;												// Should check for the previous time 						// In QML duration is in milliseconds, AE seconds						parsedTime = Math.round((time - prevTime) * 1000);																			if (key == "position") {							qmlAnimSet.push(								"ParallelAnimation {",								""							);						}											if (key == "anchorPoint") {							qmlAnimSet.push(								"AnchorAnimation {"							);						}						else if (key == "rotation") {							qmlAnimSet.push(								"RotationAnimation {"								// shoud check for direction...							);						}						else {							qmlAnimSet.push(								"NumberAnimation {"							);						}											// position needs two, x and y						var qmlProp = "";						switch (key) {							case "position" :								qmlProp = "x";								break;							default : 								qmlProp = key;								break;						}																// Took out the difference calculation as the actual values are used in QML						var type = pgk.propertyValueType;						// type can be 						//   PropertyValueType.OneD						//   PropertyValueType.TwoD_SPATIAL						//   PropertyValueType.ThreeD_SPATIAL						if (type == PropertyValueType.OneD) {							parsedValue = round2(parseFloat(value)) // - parseFloat(initValue));						}						else if (type == PropertyValueType.TwoD_SPATIAL || 								type == PropertyValueType.TwoD || 								type == PropertyValueType.ThreeD_SPATIAL || 								type == PropertyValueType.ThreeD) {																parsedValue = [								round2(parseFloat(value[0])), // - parseFloat(initValue[0])),								round2(parseFloat(value[1])) // - parseFloat(initValue[1]))							];							if (value.length > 2) {								// Since mostly everything happens in two dimensions, there is no need for the third value which 								// in most cases would be zero or something else. But check for it, just in case.								// For scale it would be 100								var third = parseFloat(value[2]) // - parseFloat(initValue[2]);								if (third > 0) {									parsedValue.push(third);								}							}						}						else {							parsedValue = null;						}																					// special cases, QML opacity is 0..1, while AE is 0..100						if (key == "opacity") {							parsedValue = round2(parsedValue / 100);						}									else if (key == "scale") {							parsedValue[0] = round2(parsedValue[0] / 100);							parsedValue[1] = round2(parsedValue[1] / 100);						}																		qmlAnimSet.push(							"\t" + "id: " + id + "_" + index.toString(),							"\t" + "duration: " + parsedTime.toString() + " // ms",							"\t" + "property: \"" + qmlProp + "\"",							"\t" + "target: " + id + ".sTarget"						);											// These should be PropertyChanges..... maybe						if (typeof parsedValue == "number") {							qmlAnimSet.push(								"to: " + parsedValue.toString()							);						}						else { // assume array														qmlAnimSet.push(								"to: " + round2(parsedValue[0] - (key == "position" ? anchorX : 0)),							);						}																						comments.push("time: " + time.toString() + ", prevTime: " + prevTime.toString() + ", value: " + value.toString() + ", type: " + type);						comments.push("parsedTime: " + parsedTime.toString() + ", parsedValue: " + parsedValue.toString() + ", initValue: " + initValue.toString());												// position seems to have spatial values, which are not always the same..., but most of the time just three zeroes						// When true, the named property defines a spatial value. Examples are position and effect point controls.						if (pgk.isSpatial) {							// Returns the incoming spatial tangent for the specified keyframe, if the named property is spacial (that is, the value type is TwoD_SPATIAL or ThreeD_SPATIAL).							var spaIn = pgk.keyInSpatialTangent(index);							var spaOut = pgk.keyOutSpatialTangent(index);							comments.push("spaIn: " + spaIn.toString() + ", spaOut: " + spaOut.toString());														// Returns true if the specified keyframe has spatial auto-Bezier interpolation. (This type of interpolation affects this keyframe only if keySpatialContinuous(keyIndex) is also true.)							var spatialAutoBezier = pgk.keySpatialAutoBezier(index);							comments.push("spatialAutoBezier: " + spatialAutoBezier.toString());													var spatialCont = pgk.keySpatialContinuous(index);							comments.push("spatialCont: " + spatialCont.toString());						}																var intpolIn = interpolationTypeString(pgk.keyInInterpolationType(index));						var intpolOut = interpolationTypeString(pgk.keyOutInterpolationType(index));						var intpolationType = pgk.keyframeInterpolationType;						comments.push("intpolIn: " + (intpolIn) + ", intpolOut: " + (intpolOut) + ", intpolationType: " + intpolationType);						var qmlEasing = "Easing.Linear";						if (intpolIn == "bezier" && intpolOut == "bezier") {							qmlEasing = "Easing.InOutCubic";						}						else if (intpolIn == "bezier") {							qmlEasing = "Easing.InCubic";												}						else if (intpolOut == "bezier") {							qmlEasing = "Easing.OutCubic";												}																											// The KeyframeEase object encapsulates the keyframe ease settings of a layer’s AE property. 						// There are two types of ease, temporal and spatial, which are determined by the speed and influence settings.						var tEaseIn = pgk.keyInTemporalEase(index);						var tEaseOut = pgk.keyOutTemporalEase(index);						comments.push("tEaseIn: " + objectValues(tEaseIn));						comments.push("tEaseOut: " + objectValues(tEaseOut));						// { influence: 0...100, speed: }												var qmlBezierCurve = [							round2(tEaseIn[0].influence / 100), 0,							round2(tEaseOut[0].influence / 100), 1,							1, 1						];												// Easing bezier curves are supported from Qt Quick 2.0 onward...						if (qtQuickVersion == "2.0") {														qmlAnimSet.push(								"easing.type: Easing.Bezier",								"easing.bezierCurve: [" + qmlBezierCurve.toString() + "]"							);							// control1, control2, end point: [cx1, cy1, cx2, cy2, endx, endy].  The last point must be 1,1.						}						else { 							// Should be Qt Quick 1.1												if (qmlEasing != "") {								qmlAnimSet.push(									"easing.type: " + qmlEasing,									"// easing.bezierCurve might be: [" + qmlBezierCurve.toString() + "]"								);							}						}												/*						KeyframeInterpolationType.LINEAR						KeyframeInterpolationType.BEZIER						KeyframeInterpolationType.HOLD						*/												var temporalAutoBezier = pgk.keyTemporalAutoBezier(index);						comments.push("temporalAutoBezier: " + temporalAutoBezier.toString());																		// Temporal continuity affects this keyframe only if keyframeInterpolationType is KeyframeInterpolationType.BEZIER for both keyInInterpolation(keyIndex) and keyOutInterpolation(keyIndex) .						var temporalCont = pgk.keyTemporalContinuous(index);						comments.push("temporalCont: " + temporalCont.toString());												// Most of the time all return true						//comments.push("isInterpolationTypeValid(KeyframeInterpolationType.LINEAR): " + pgk.isInterpolationTypeValid(KeyframeInterpolationType.LINEAR));						//comments.push("isInterpolationTypeValid(KeyframeInterpolationType.BEZIER): " + pgk.isInterpolationTypeValid(KeyframeInterpolationType.BEZIER));						//comments.push("isInterpolationTypeValid(KeyframeInterpolationType.HOLD): " + pgk.isInterpolationTypeValid(KeyframeInterpolationType.HOLD));																											if (key == "position") {							qmlAnimSet.push(								"}",								"NumberAnimation {",								"\t" + "id: " + id + "_" + index.toString() + "_y",								"\t" + "duration: " + parsedTime.toString() + " // ms",								"\t" + "property: \"y\"",								"\t" + "target: " + id + ".sTarget",								"to: " + round2(parsedValue[1] - anchorY) + " // " + parsedValue[1] + " - " + anchorY							);							// Easing bezier curves are supported from Qt Quick 2.0 onward...							if (qtQuickVersion == "2.0") {																qmlAnimSet.push(									"easing.type: Easing.Bezier",									"easing.bezierCurve: [" + qmlBezierCurve.toString()  + "]"								);								// control1, control2, end point: [cx1, cy1, cx2, cy2, endx, endy].  The last point must be 1,1.							}							else { 								// Should be Qt Quick 1.1														if (qmlEasing != "") {									qmlAnimSet.push(										"easing.type: " + qmlEasing,										"// easing.bezierCurve might be: [" + qmlBezierCurve.toString() + "]"									);								}							}						}																					// seems that opacity always has min and max, which are 0 and 100.						if (pgk.hasMin) {							var min = pgk.minValue;							comments.push("min: " + min.toString());						}						if (pgk.hasMax) {							var max = pgk.maxValue;							comments.push("max: " + max.toString());						}																						qmlAnimSet.push(							"\t" + "// " + comments.join(lineFeed + "\t\t// "),							"\t" + "",							"}" // NumberAnimation or similar...						);												if (key == "position") {							qmlAnimSet.push(								"}" // ParallelAnimation							);						}											// save the current for the next iteration						prevTime = time;						prevValue = parsedValue;												qmlAnim.push(							qmlAnimSet.join(lineFeed + "\t\t")						);					}															qmlAnim.push(						"}" // SequenceAnimation												//"}" // AnimationController					);										// initial values					// it seems these are no longer needed once the layer properties are checked earlier...					/*					if (typeof initValue !== "undefined") {						if (key == "position") {							qmlItem.push(								"x: " + round2(initValue[0]).toString(),								"y: " + round2(initValue[1]).toString()							);						}						else if (key == "scale") {							// QML has only a single scale value...							qmlItem.push(								"scale: " + round2(initValue[0].toString() / 100)							);						}						else if (key == "opacity") {							// please note this is commented out for testing purposes only...							qmlItem.push(								"// opacity: " + round2(initValue.toString() / 100)							);						}						else if (key == "rotation") {							qmlItem.push(								"rotation: " + initValue.toString()							);						}											}					*/									qmlItem.push(						qmlAnim.join(lineFeed + "\t")					);				}			}					return qmlItem.join(lineFeed + "\t");		}								function renderCommonQML(content) {			var lines = [				"import QtQuick " + qtQuickVersion, 				"import \"Prosessor.js\" as Prosessor;",				"",				"Rectangle {",				"",				"width: 1200",				"height: 1200",				""			];									// add more stuff....			lines.push(content);									lines.push(				"", 				"}", // Rectangle				""			);			return lines.join(lineFeed);		}										if (app.project) {			app.beginUndoGroup(scriptName);						if (app.project.file) {				// set the default/initial value for folder				outputFolder = app.project.file.path;								BuildAndShowUI(thisObj);			}			else {				alert(scriptName + "\n" + "Please save the current project first", "Project not saved", true);			}			app.endUndoGroup();					}		else {			alert(scriptName + "\n" + "Please open or create a project with compositions first before using this script", "Project does not exist", true);		}	}		ExportCompTransition(this);}